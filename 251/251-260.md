## 252. Meeting Rooms
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.  
.  
.  
.  
.  
.  
.  
- sol : sort using start time. time=O(nlogn), space=O(1)

## 253. Meeting Rooms II
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.  
.  
.  
.  
.  
.  
.  
- sol1 : use min heap to keep track of the min end time. If the start time >= min end time, then we can use that room. time=O(nlogn), space=O(n)
- sol2 : sort start time and end time individually, use 2 pointers and compare start[sptr] and end[eptr]. If start >= end, then we can use that room. time=O(nlogn), space=O(n)

## 257. Binary Tree Paths
Given a binary tree, return all root-to-leaf paths.  
Note: A leaf is a node with no children.  
.  
.  
.  
.  
.  
.  
- sol1 : recursive, time=O(n), space=O(n)
- sol2 : iterative, time=O(n), space=O(n)

## 258. Add Digits
Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.  
.  
.  
.  
.  
.  
.  
- sol : mod 9. time=O(1), space=O(1)

## 260. Single Number III
Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.  
.  
.  
.  
.  
.  
.  
- 1. : XOR all the elements, will get axorb
- 2. : find a bit in axorb that is 1, which means a and b are different at that bit
- 3. : XOR the elements with 1/0 at that bit, a and b will be the final outcome
- time=O(n), space=O(1)
